#include<stdio.h>
#include<unistd.h>
#include<assert.h>
#define bool int

#define F_REG 1
#define F_DIR 2
#define FILE_SIZE_MAX (128 * 1024)
#define FILE_MAX 512
#define HEADER_SIZE_MAX 512
#define DENTRY_NUM(dir_header) ((dir_header)->size / sizeof(struct cell_dentry))
struct dp{
	u8 boot;
	u8 start_head;
	u8 start_sector;
	u8 start_cylender;

	u8 sys_id;//means the fs type ID.
	u8 end_head;
	u8 end_sector;
	u8 end_cylender;

	u32 start_lba;
	u32 count;
}*g_dps;
struct mbrbuf[1024];
struct cell_dentry{
	char name[16];
	int block_id;
};
struct cell_block_header{
	int size;
	char type;
};
struct cell_block{
	struct cell_block_header header;
	union{
		struct cell_dentry start[100];
		char content[FILE_SIZE_MAX - sizeof(struct cell_block_header)];
	};
};
struct cell_super_block{
	char flags[4];
	int block_size;
	int block_num;
	struct cell_dentry root;
	char block_bmp[FILE_MAX];
}sb;
char currblock[FILE_SIZE_MAX];
char cmd[16];
char arg1[64];
int mainfd;
//struct cell_dentry *pwd_block;
//struct cell_block_header *pwd_header
struct cell_block pwd_block;
struct cell_block tmp_block;
struct entpwd;		/* dentry which points to the block of 'pwd'*/
int whole_size;		/* the whole file size*/
int p_start;		/* current partation start sector id*/
int p_count;		/* current partation's sector count */
#define go_on(msg, arg) {\
	printf(msg , arg);\
	continue;\
}

#define fail_say(msg, arg){\
	printf(msg, arg);\
	exit(1);\
}

#define return_say(value, msg){\
	printf(msg);\
	return value;\
}

#define SECTOR2BLOCK(sector_num) ((sector_num * 512) / sb->block_size)
void locate_block(int block_id){
	lseek(mainfd, p_start * 512 + block_id * sb->block_size);
}
bool main_read_block(char *buf, int block_id){
	locate_block(block_id);
	read(mainfd, buf, sb.block_size);	
	return 1;
}

bool main_write_block(char *buf, int block_id){
	locate_block(block_id);
	write(mainfd, buf, sb.block_size);
	return 1;
}
struct cell_find_entry(struct cell_block *dir_block, char *name){
	int entnum = dir_block->header.size / sizeof(struct cell_dentry);
	struct cell_dentry * ent_start = dir_block->start;
	while(entnum > 0){
		if(strcmp(ent_start[entnum].name, name) == 0) return &dir_block[entnum];
		entnum--;
	}
	return 0;
}
int get_filesize(int fd){
	int oldpos = lseek(fd, SEEK_CUR, 0);
	assert(oldpos != -1);
	int size = lseek(fd, SEEK_END, 0);	
	lseek(fd, SEEK_SET, oldpos);	
	return size;
}

bool check_cell_flags(struct cell_super_block *sb){
	if(sb->flags[0] != 'c' || sb->flags[1] != 'e'  ||\
	   sb->flags[2] != 'l'|| sb->flags[3] != 'l') 
			return_say(0, "cell flags check failed");
	if(sb->block_num != SECTOR2BLOCK(p_count))
		return_say(0, "block count information not sychronised");
	return 1;	
}

bool choose_partation(int pid){
	if(pid <=0 || pid >=4) return_say(0, "invalid partation id");	
	struct dp *dp = g_dps + pid;
	p_start = dp->start_lba;
	p_count = dp->count;
	return 1;
}

struct dentry *alloc_free_entry(struct cell_block *block){
	int entnum = DENTRY_NUM(&block->header);
	block->header.size += sizeof(struct cell_dentry);
	return block->start + entnum;
}

int alloc_free_block(struct cell_super_block *sb){
	for(int i = 0; i < FILE_MAX; i++){
		if(sb->block_bmp[i] == 0){
			sb->block_bmp[i] = 1;
			return i;
		}
	}
	return 0;
}

void info_dp(struct dp *dp){
	for(int i = 0; i < 3; i++){
		printf("%d", )
	}
}
int main(int argc, char *argv[]){
	mainfd = open(argv[1], O_RDWR);
	if(!mainfd) fail_say("open failed: %s", argv[1]); 
	read(mainfd, mbrbuf, 1024);
	read(mainfd, (char *)&sb, 1024);
	
	g_dps = (void *)(mbrbuf + 446);

	//if(!check_cell_flags(&sb)) printf("cell filesystem undetected !");
	while(scanf("%s%s", cmd, arg1) != EOF){
		//printf("%s > %s", cmd, arg1);
		if(strcmp(cmd , "format") == 0){
			
		}
		else if(!check_cell_flags(&sb))
			go_on("");
		else if(cmd[0] > '0' && cmd[0] < '9'){
			int ok = choose_partation(cmd[0] - 30);
			if(ok) printf("partation %c now\n", cmd[0]);
			else printf("failed\n");
		}
		else if(strcmp(cmd, "cd") == 0){
			if(strlen(arg1) <= 0) go_on("second arg missing", 0)
			struct cell_dentry *ent = cell_find_entry(&pwd_block, arg1);
			if(!ent) go_on("can not find %s", arg1)
			main_read_block(tmp_block, ent->block_id);
			if(tmp_block->header.type == F_DIR){
				pwd_block = tmp_block;
				entpwd = ent;
				printf("ok\n");
			}
			else go_on("not a directory:%s", arg1);
				
		}
		else if(strcmp(cmd, "cat") == 0){
					
		}
		else if(strcmp(cmd, "cp") == 0){
			char newname[64];
			scanf("%s", newname);
			int fd = open(arg1);
			if(fd == -1) go_on("open failed: %s\n", arg1 )
			int size = read(fd, (char *)tmp_block, FILE_SIZE_MAX);
			tmp_block.header->size = size;
			tmp_block.header->type = F_REG;
			/*ok, we loaded the source file and prepare for writing*/
			/*firstly, find a new dentry and block if no same-name file exsits*/
			struct dentry *ent = cell_find_entry(&pwd_block, newname);	
			if(ent)	;/*we are lucky*/
			else{
				ent = alloc_free_entry(&pwd_block);
				if(!ent) go_on("no free dentry left in %s\n", arg1);
				int bid = alloc_free_block(&sb);
				ent->block_id = bid;
			}
			main_write_block(&tmp_block, ent->block_id);
			main_write_block(&pwd_block, entpwd->block_id);
			}
		}
		else if(strcmp(cmd, "mkdir") == 0){
		}
	}
	return 0;
}















