
Sat Jun  6 21:03:16 EDT 2015
  1,更改了strcmp，不再返回boolean，现在像ｃ标准一样。debug.c里似乎用到了strcmp，姜涞改过来。
Sat Jun  6 18:15:30 EDT 2015
1,ramdisk基本通过了。要修改头文件的参数，并能指定文件数。
Sat Jun  6 09:16:11 EDT 2015
1,似乎boot.asm和bootinfo.asm同时保存，才保险。不然似乎又Ｂｕｇ。
2,0x50000替换0x30400的话，系统会卡死
Thu Jun  4 18:19:19 EDT 2015
实模式下，把扇区读到ramdisk memory buffer就行了。
14,may
  8,因为重点不是文件系统，其它有要做的。
  7,做功能性的东西不难。但模仿一个框架要花时间。而且琐碎，就要先衡量这有
没有价值。
--------------------
  6,还是先不写文件系统，也不写磁盘驱动。
  将来文件系统和磁盘驱动都模仿2.4或2.6。
  现在在文件操作上尽量简洁的凑合，例如伪造一个read，例如用ramdisk。总之
是尽量简洁的凑合。
---------------
  2,不想再用虚拟磁盘写磁盘驱动，觉得许多端口delay的细节会不一样。
  例如，一个command写入端口，在硬盘上要多久收到中断？再虚拟盘上又要多久
收到？也许是handler刚退出，就收到被串行化的再次中断，也许是返回用户进程，
也许是用户进程运行一段时间之后。
  3,写ram disk吧。等可以方便的做硬件测试时，再写磁盘驱动。
  4,cell文件系统还是做，在ubuntu上写读写它的工具，在内核里写基于它的文件
系统。
  5,在系统刚启动时，把这个虚拟磁盘加载成ram disk。
  ----------
  1,赵炯那本书，一些部分只能当文档读，比文档还差些。

13,may
  4,在ring3级别下，空的directory entry或table entry仍然引发缺页异常，
  而不是保护异常。今天这个观点差点被颠覆了。
    因为一段旧的代码，我把堆栈base上的第一个页手动映射称系统页面，而且
  这个操作是再流程靠后部分，导致我怎么弄，do_page_fault给出的都是
  页面保护异常。error_code是7，怎么都成不了６．

  5,page exception的除错码，其中的US指示页错误发生时，CPU的特权级，是
  用户级别，还是系统级别。这个信息不太重要。因为通过堆栈上的CS也能知道。
  出错码就是指示，这个页错误是在那个级别下，因为读/写，引发的缺页还是
  页保护故障。
  ----
  1,今天出现了bug不可重复的现象，调节realtime, none这样的option，会有不
同的结果。目前再slowdown下是正常的。
  2,今天想把内核放到机器上测试，却跑不起来。我的dimg似乎不能以硬盘为目标
 ,但它又没报错。发现用dd工具似乎可以完成dimg的功能，使用它的seek和skip
 选项。但要小心，今天的u盘分区表不知怎么就被毁了.
  3,ring3进程调通了一部分。还不能用堆栈。

12,may
  如果执行jmp时中断了，那返回时，执行的岂不是jmp的下一条指令?

11,may
18:14 ０~15号异常处理的框架写好了。开了一个ring3进程，双重页错误。明天
调试。最好能早些解决，然后写syscall的框架。
这样，异常，中断，时钟中断，系统调用的框架都写好了。
然后写磁盘驱动和cell文件系统。
键盘驱动，挂tty，可以放在fork中间顺便写，因为想赶紧写进程那一片。


20,april

*fix a bug caused by not-purposed text-edit damage. I deleted a code line in 'boot.asm>dap'. just merge this file using a good 'boot.asm' file.

df -h

×再内核进程的代码里，如果主动调用shedule，需要提前__SAVE，否则下一次被调度时，
它只能从最近一次被调度的状态重新运行。今天就出了这个bug。
因此增加kthread_sleep函数。
用户进程没有这个顾虑，当它陷入内核，control path可以随时调用schedule，不过调用，
也就意味着这次陷入（中断或异常）处理结束了。
control path也可以让用户进程休眠，这也意味着本次conrol path的结束。进程再度被
唤醒时，会接着在用户空间运行，认为异常处理已经结束了。
因此像read这样的函数是这样运作的，control path（常是再fs虚拟层）让asker休眠，并把cmd传递给具体文件系统（像fs_ext），fs_ext完成了read请求，会找到asker的pcb，并把这次系统调用的返回值放进去，并唤醒它，这次的系统呼叫就算完成了。
但要注意一点，这次系统呼叫的control path是在让用户休眠的时候，就已经结束了。因为用户再不可能回到那次control path的断点。control path结束了，但决不能让asker立刻
醒过来，要等文件系统真正意义上完成它的请求后，由文件系统唤醒它。


*内核进程再正常的时钟中断调用下，是能够正确保存，恢复现场的。
但是在kthread_sleep时就出页错误了。

*对c语言中的标签去地址，用&&label,是gcc的扩增特性

*今天给内核进程写了一个kthread_sleep函数，它的功能是，把这个内核进程挂到sleep
队列，然后用i81h保存现场，通过0x80门所进入的代码段，进一步保存现场，并调用
schedule。
这样，kthread就睡眠，并放弃了时间片。
核心语句是一条__asm__ ("int $0x80");它起到保存内核进程现场，并呼叫schedule的功能。
*明天写完irg服务例程队列会很快，但要把整个内核重新做基于它的调整，要有耐心。

