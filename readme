【1】 
papaya内核是我学习linux的一个习作。
很多人是通过读源码来学习它，我觉得写一个与它平行的内核，是另一种方式。

每开始写一个模块，都是先把《linux内核情景分析》的章节看一遍，在纸上涂涂画画，心里有一个蓝图，再开始写。

早期的时候，会翻看linux的源码，希望跟它一致，papaya的初衷就是modern linux的简化版。但慢慢发现，尤其是写过块设备层之后发现，刻意的模仿linux，写的很累，而且收获很小。
跟它保持差异，反而能能体会到它为什么会那样设计。。。等等。。。其它学习方式的细节，也都是不断摸索的。

在写的时候，一直告诉自己，这个内核不重要，重要的是人，你自己通过它能学到多少。
  
虽然这样，还是希望把这个内核写到某种极致。


【2】
src/ 下面是源码
include/  早期的头文件。 后来的都放在src/include。
cmd/ 调试时用到的小工具。包括刻录到虚拟img，刻录到usb等等。
lsh/ 我平时工作时用到的shell。 自己写的，叫lua shell。因为有还在完善中，工作时遇到bug随手改过来，所以也一并上传。


【3】
[2016,7,27] Version 0.607b
==========update===========
1, TCP implementation. Receive only.  See net/ipv4/tcp.cn
2, Chinese Programming introduced. 	  Also see tcp.cn
3, Mutliple NICs support.			  See net/core/dev.c @pick_nic()

[2016,7,12] Version 0.607
==========update==========
1, New feature: bottom monitor window.   see lib/printf.c
2, The driver for RTL8139.
3, ARP layer, IP layer.


[2016,6,5]Version 0.606
==========update==========
1, memory management module: SLAB (without colouring)	
   see src/mm/slab.c


[2016,5] Version 0.605
==========update===============
1, block device layer without buffer
2, ide driver
3, virtual filesystem( interfaces: open(), read(), close() implemented, write() not yet)


【4】
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
空间博客：http://user.qzone.qq.com/2106507650/2


================ 2016 9,4 更新===============
　　papaya os目前的代码量约8000行。
　　目前完成的有：
　　内存管理:
			buddy system		<mmzone.c>
			slab allocator		<mm/slab.c>
			slab分配器是不带color的。

	网络：
			8139网卡驱动		<drivers/net/8139.c>
			arp协议				<net/ipv4/arp.c>
			简单的ip协议		<net/ipv4/ip.c>
			部分udp协议			<net/ipv4/udp.c>			
			部分icmp协议		<net/ipv4/icmp.c>
			部分tcp协议			<net/ipv4/tcp.cn>
			I 整个网络模块是在六七月份写完的，到了七月底，进度越来越慢，tcp协议栈没能按计划完成。不过其它部分，像arp, ip重组，udp以及icmp都通过了测试。
			II papaya支持多网卡，这是我很骄傲的一点。
			III 我在tcp.cn里尝试了中文编程。感觉还好。
		
	
	文件系统:
			vfs					<fs/*>
			cell文件系统		<fs/cell/*>
			I vfs只实现了open, read, lseek, close接口。　另外就是mount。
			II 	cell文件系统是我自己"发明"出来的，顾名思义，就是“划格子”，很简单的一个文件系统，它好在自己没有inode等概念，但却跟vfs配合的很好。这是我很满意的一次尝试，我通过它学到了很多。

	
	块设备：	
			IDE驱动			<drivers/ide/ide.c>
			块设备驱动		<drivers/block/ll_rw_blk.c>
			块设备层是不带buffer的。

	基础：
			fork()			<fork.c>
			schedule()		<schedule.c>
			kmalloc()		<pmm.c>
			bottom half		<kernel/bh.c>
			printf()		<lib/printf.c>
			I papaya os的进程调度算法几乎是没有，而且以后很长一段时间都不会考虑。
			II 基于slab的kmalloc叫做kmalloc2(),　因为papaya还保留着一个早期的堆，是链表实现的。
			III papaya的bh.c实现的精简至极，而且跟linux不太一样。


	几个入口文件：
			boot.asm	==>		kernel.asm		==>		kernel.c
				

